1.高性能硬件上的程序部署策略

例如：一个 15 万 PV/天左右的在线问答类型网站最近更换了硬件系统，新的硬件为 4 个 CPU 、16GB 物理内存，操作系统为 64 位 CentOS 5.4，
Resin 作为 Web 服务器.

管理员为了尽量利用硬件资源选用 64 位的 jdk1.5，并通过 -Xmx 和 -Xms 将 Java 堆固定在 12 GB. 使用一段时间后，效果还是不理想，网站
还是会经常不定期长时间出现失去响应的情况.

虚拟机运行在 Server 模式，默认使用吞吐量优先收集器，回收 12 GB 的堆，一次 Full GC 的停顿时间高达 14s.

目前有两种解决办法：

1.通过 64 位 JDK 来使用大内存
2.使用若干个 32 位虚拟机简建立逻辑集群来利用硬件资源

使用超大堆内存有一个前提，就是有把握把应用程序的 Full GC 频率控制得足够低，至少要低到不会影响用户使用，譬如十几个小时乃至一天才会出现
一次 Full GC，这样就可以通过在深夜执行定时 Full GC 的方式触发 Full GC，甚至是重启服务来使得服务器保持内存可用空间在一个稳定的水平.

控制 Full GC 的频率的关键，在于看应用中绝大部分对象是否是朝生夕死的原则. 这样才能保障老年代空间的稳定.

第二种做法是使用若干 32 位的虚拟机建立逻辑集群来利用硬件资源. 一台物理机上启动多个应用服务器进程，每个服务器进程分配不同的端口，然后在
前段搭建一个负载均衡器，以反向代理的方式来分配访问请求.


2.集群建同步导致的内存溢出

有一个基于 B/S 的 MIS 系统，硬件为两台 2 个 CPU、8GB 内存的 HP 小型机，服务器是 WebLogic9.2，每台机器启动 3 个 WebLogic 实例，
构成一个 6 个节点的亲和式集群.

亲和式集群说的是 session 具有粘性，第一次请求访问的是那个服务器，那么以后就都访问哪一个服务. 所以服务器之间就不存在 session 同步了.

由于集群共享数据要使用类似 JBossCache 这种集群缓存来同步，在网络不好的情况下，重发数据在内存中不断堆积，很快就产生了内存溢出.

这类数据可以允许读操作频繁，但是应当避免写操作频繁发生.


3.堆外内存导致的溢出错误

为了实现客户端能实时地从服务器端接收考试数据，系统使用 Comet 长连接推送数据到客户端.

虚拟机虽然会对 Direct Memory 进行回收，但是 Direct Memory 却不能像新生代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等
老年代满了后 Full GC，然后顺带的帮忙清理掉内存的废弃对象.

一般来说，除了 Java 堆和永久代，下面这些区域还会占用较多的内存，这里所有的内存总和会收到操作系统进程最大内存的限制.

(1)Direct Memory：可以通过 -XX:MaxDirectMemorySize 调整大小，内存不足时抛出 OutOfMemoryError 或者 OutMemoryError:Direct
buffer memory.

(2)线程堆栈：可通过 -Xss 调整大小，内存不足时抛出 StackOverflowError 或 unable to create new native thread

(3)Socket 缓冲区：每个 Socket 连接都 Receive 和 Send 两个缓存区，分别占大约 37KB 和 25KB 内存，连接多的话这块内存占用也比较
可观, 如果无法分配，则可能会抛出 IOException: Too many open files 异常.

(4)JNI 代码：如果代码中使用 JNI 调用本地库，那本地库使用的内存也不在堆中.

(5)虚拟机和 GC：虚拟机、GC 的代码执行也要消耗一定的内存.

4.外部命令导致系统缓慢

虚拟机执行外部命令时，首先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再推出退出这个进程. 如果
频繁调用，CPU 和内存负荷会很大.

5.服务器 JVM 进程崩溃

在做系统集成的时候，由于两边服务器处理的速度不对等，导致 MIS 这边越来越多的代办事项没有调用完成，导致在等待的线程和 Socket 连接越来
越多，最终在超过虚拟机的承受能力后，虚拟机进程崩溃.
解决办法：我觉得使用消息中间件可能会更好.

6.不恰当的数据结构导致内存占用过大

在把一个 80M 的文件加载到内存中进行分析的时候，发现 Minor GC 后还是有大量对象存活.

看下数据结构：HashMap<Long, Long>

有效数据占 16B，这两个 long 型数据包装成 Long 对象后，就分配具备了 8B 的 MarkWord, 8B 的 Klass 指针(对象头)，再加 8B 的存储
数据(实例数据)，在这两个 Long 对象组成 Map.Entry 之后，又多了 16 B 的对象头，然后是 8B 的 next 字段和 4B 的 int 型的 hash 字段，
为了对齐，还必须添加 4B 的空白填充，最后还有 HashMap 中对这个 Entry 的 8B 引用，利用率太低了.

7.由 Windows 虚拟内存导致的长时间停顿


8.实战：Eclipse 运行速度调优

(1)升级 JDK，希望从虚拟机版本身上得到一些免费的性能提升.
(2)默认情况下，虚拟机永久代的大小默认为 64KB.
(3)调整内存设置控制垃圾收集频率
(4)选择收集器降低延迟

