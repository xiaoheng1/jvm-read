1.我们都知道 CPU 的处理速度很快，但是访问主存的速度很慢. 然而计算任务不只是只计算就完了，它还需要读取主存中的数据，这样 CPU 的效率
会被主存的访问速度拖累. 为了提高 CPU 的效率，进而引入了高速缓存(cache). 当需要读取某些数据的时候，CPU 访问cache，如果cache上没有
该数据，则会将数据从主存加载至 cache，这样就解决了主存和 CPU 速度不匹配的问题.

世上没有事是完美的，引入了 cache 是好，但是也带来了另一个问题：缓存一致性问题.

在多处理器系统中，每个处理器都有自己的 cache，而 cache 和主存打交道. 当多个处理器的运算任务涉及到同一内存区域的时候，可能在各个
处理器上缓存的数据不一致. 那么数据从 cache 同步会主存时以哪个 cache 上数据为准了？

为了解决上述问题，就有了 MESI、MSI、MOSI 协议 等.

下面介绍上面其中的一种协议的内容(MESI):

每一个缓存行有 M E S I 四种状态.
M：被修改了(仅在本 CPU 中缓存了，和内存中的数据不一致)
E：独占(仅在本 CPU 中缓存了，且数据和内存中的数据一致) 
S：共享(在多个 CPU 中都有缓存，且与内存中的数据一致) 
I：无效(要么已经不再缓存中了，要么该缓存过时了)

M：一个处于M状态的缓存行，必须时刻监听所有读取该缓存行对应的主存地址的操作，如果监听到，
则必须在此操作前把缓存行写会到主存，并把状态变为 S 
E：一个处于E状态的缓存行，必须时刻监听试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把 E 状态设置为 S 
S：一个处于S状态的缓存行，必须时刻监听使该缓存行无效或独占该缓存行的操作，如果监听到，则标记该缓存行为 I

只有对 M、E 进行写操作不需要额外的操作，如果对 S 状态缓存行进行写操作，则必须先发送一个 RFO 请求广播， 
该广播可以让其他CPU的缓存中的相同数据的字段失效，即变成I状态.

2.Java 内存模型.

不同的物理硬件和操作系统的内存模型不一样，比如一段程序在 window 上并发没有问题，但是在 linux 环境可能存在问题. 基于上述问题，Java
试图定义一种内存模型，来屏蔽底层硬件和操作系统内存模型的差异，做到编写一次，到处运行.

JMM(Java Memory Model) 定义了主内存和工作内存.


线程1         线程2
  |            |
工作内存     工作内存
  |            |
 ----------------
      主内存

工作内存存放的数据是主内存中的拷贝副本. 需要说明的是，这里的拷贝副本不是说将整个对象都拷贝过去，可能将该主内存中该对象的引用以及
使用到的字段拷贝到工作内存.

注意: 这里说的主内存和我们计算机硬件中的主内存含义不同，但是这种交互模式和主内存和缓存的那种交互模式一致(类比).
还需要说明一点的是，这里的主内存、工作内存和 Java 内存区域的划分方式是两种划分方式. 如果非要进行类比的话，主内存相当于内存区域中
堆的部分，而工作内存相当于栈的部分.

3.内存间的交互操作

看到这块，小伙伴是否有这么一个疑问？不同的工作内存缓存了主内存中相同的数据，那么是否有类似于 MESI 这样的协议来保证数据一致性了？

我们先来看下内存间的交互操作吧.

内存间的交互是数据从主内存拷贝到工作内存，然后从工作内存同步会主内存的具体实现细节.

Java 内存模型定义了 8 中操作来完成，虚拟机实现时必须保证这 8 中操作都是原子操作(对于 double 和 long 型变量来说，
load、store、read 和 write 允许有例外).

(1)lock: 作用与主内存的变量，它把一个变量标识变为一个线程独占的状态.
(2)unlock: 作用于主内存的变量，解锁，只有解锁完后，其他线程才能锁定.
(3)read: 作用于主内存，把一个变量的值从主内存传入到工作内存中，以便随后的 load 动作使用(类似于实参).
(4)load: 作用于工作内存中的变量，它把 read 操作从主内存中得到的值放入工作内存的变量副本中(类似于形参).
(5)use: 作用于工作内存的变量，它把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行
这个操作.
(6)assign: 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行
这个操作.
(7)store: 作用于工作内存的变量，它把工作内存中一个变量的值传到主内存中，以便随后的 write 操作使用.
(8)write: 作用于主内存的变量，它把 store 操作从工作内存得到的变量的值放入主内存的变量中.

作用于主内存的操作：lock/unlock、read/write
作用于工作内存的操作：load/use/assign/store

对 lock/unlock 的分析：
在 JVM 中，并没有把 lock/unlock 直接开放给用户，而是提供了更高级别的 monitorenter/monitorexit 来间接操作 lock/unlock，
而 monitorenter/monitorexit 又和 synchronized 相关联. 我们知道 synchronized 在释放锁的时候，会将cache 中的值同步会主存，
这一点和 unlock 规则对应. 而 lock 只能被一个线程锁定，且对同一个线程可重入锁定.


注意：
(1)JMM 要求 read 和 load 操作以及 store 和 write 操作必须按照顺序执行(不一定连续执行).
(2)read 和 load、store 和 write 操作必须成对出现.
(3)不允许一个线程丢弃它的最近 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存(这里没有说立即同步喔，所以我们
会遇到多线程累加某一个变量的值100次，最后可能结果不到200).
(4)不允许一个线程无原因地(没有发生过任何 assign 操作)把数据从线程的工作内存同步回主内存中.
(5)一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量，换句话说，就是对一个变量实施
use、store 操作之前，必须先执行过了 assign 和 load 操作(对应java语法规则是变量必须初始化后才能使用).
(6)一个变量在同一时刻只允许一条线程对齐进行lock操作，但lock操作可以被同一条线程重复执行多次，多次lock后，只有执行相同次数的unlock
操作，变量才会被解锁(对照 synchronized 分析).
(7)如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化
变量的值.
(8)对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行 store、write 操作).

unlock：当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中

lock：当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量

一个疑问：JMM **中工作内存只和主存打交道一次吗**？

答案是肯定不止一次. 
(1)每次使用变量时，都必须从主内存刷新最新的值，用于保证能看见其他线程对该变量的修改后的值.
(2)在工作内存中，每次修改变量后都必须立即同步会主存，用于保证其他线程可以看到自己对该变量的修改.

4.对 volatile 类型变量的特殊规则

volatile 关键字修饰的变量具备两种特性：1.保证此变量对其他线程可见 2.禁止指令重排

这里说的保证变量对其他线程可见，是说对 volatile 关键字修饰变量的修改，都会反映到其他线程中. 这个是如何实现的了？
被 volatile 关键字修饰的变量在被编译后，会新增一个带 lock 前缀的指令，例如：lock addl $0x0, (%esp)，这个操作相当于一个内存
屏障，这个带 lock 前缀的指令会引起其他 CPU 的 cache 缓存数据无效(相当于进行了一次 store 和 write 操作)，可以让前面 volatile
变量的修改对其他 CPU 立即可见.


对 long 和 double 型变量的特殊规则

JVM 规定可以对没有 volatile 关键字修饰的 64 位的数据类型读写操作划分为两次 32 位的操作来进行，即：允许虚拟机不保证 long 和 
double 数据类型 read/load store/write 的原子性操作. 但是目前的虚拟机都实现了 long 和 double 的原子操作.

5.原子性、有序性和可见性

JMM 就是围绕如何处理这三个特性的.
原子性：lock、read、load、use、assign、store、write、unlock
可见性：volatile. 无论是普通变量还是 volatile 变量，都会将修改后的值同步回主内存. **区别是，volatile 的特殊规则保证新值能立即
同步会主存，而普通变量则无法保证**.

synchronized 和 final 也能实现可见性. synchronized 可以实现可见性是因为在执行 unlock 之前，
会将数据刷新会主存(store、write).

final 关键字的可见性是指：被 final 关键字修饰的字段在构造器中一旦初始化完成，并且构造器中没有发生引用逃逸，那么在其他线程中就能
看到 final 字段的值.

有序性：线程内表现出串行语义，但是可能是乱序执行的.


6.先行先发原则(happen-before)

如果操作 A 先行发生于操作, 其实就是说发生在操作 B 之前，那么操作 A 产生的影响能被操作 B 观察到. "影响"包括修改了内存中共享变量
的值、发送消息、调用了方法等.

// 线程 A
int i = 1
//线程 B
j = i
// 线程 C
i = 2

假设线程A中的操作先于B操作，那么可以确定在线程B操作执行后，变量 j 的值一定为1. 现在考虑线程 C，那么线程 B 的结果可能是1，也可能
是 2.

程序次序规则：在一个程序内，按照程序代码顺序，前面的代码先于后面代码发生.
管程锁定规则：一个 unlock 操作先行发生于后面对同一锁的 lock 操作.
volatile规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作.
线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每一个动作
线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测
线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生.
对象终结规则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始.
传递性：如果操作 A 先于B，B先于C，那么A先于C.

事件上先发生的，不代表一个操作是先行先发. 事件先后顺序与先行先发原则没有太大关系，所以我们衡量并发安全问题的时候不要受到时间顺序
干扰，一切必须以先行先发原则为准.


7.Java 与线程

java 中和线程相关的是 Thread 这一个类，我们发现这个类的 API 和其他类的 API 有显著差异，这个类中大部分方法是 native 修饰的.

实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现.

(1)内核线程，就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务
映射到各个处理器上.
(2)轻量级进程就是我们通常意义上的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程.
(3)使用用户线程，广义上讲，只要不是内核线程，就可以认为是用户线程，从这个意义上讲，轻量级进程也属于用户线程. 从狭义上讲，用户
线程指的是完全建立在用户控件的线程库上，系统内核不能感知线程存在的实现.用户线程的建立、同步、销毁和调度完全不需要切换到内核态.


线程调度：

线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度.
协同式是线程把自己的工作执行完后，要主动通知系统切换到另一个线程上(实现简单，没有什么线程同步问题).
抢占式：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定.


状态转换：

关于这点可能有的小伙伴有疑问了？线程状态不是只有 5 种状态吗？为啥会有 6 种状态了？其实 5 种状态是早期进程的状态.

1.创建状态：创建进程过程非常复杂，首先需要申请一个空白的 PCB，并向线程中写入用于控制和管理进程的信息. 然后为其分配必要的资源，
  最后把线程加入到就绪队列中
2.就绪状态：就绪状态就是说该线程已经准备好运行，只要给我时间片，我就能运行.
3.运行状态：指的是已经获取 CPU 的进程，目前处于执行状态.
4.阻塞状态：指的是正在执行的进程由于发生某件事，例如 I/O 操作等，暂时无法执行，这个状态称为阻塞状态.
5.终止状态：终止状态指的是线程的最终状态，要么线程执行完，要么由于无法解决的错误，被操作系统终止，或者被有权限终止的线程终止.

转换规则：

1.创建状态 -> 就绪状态
     获得时间片
2.就绪状态 -> 运行状态
     时间片用完 
3.运行状态 <- 就绪状态
       I/O操作
4.运行状态 -> 阻塞状态
     I/O操作完成
5.阻塞状态 -> 就绪状态

线程的 6 大状态

1.初始状态 —— NEW(线程刚被创建，但是还没有调用 start 方法)
2.运行状态 —— RUNNABLE(Java 线程将就绪和运行两种状态统称为运行中)
3.阻塞状态 —— BLOCKED(阻塞状态，表示线程阻塞于锁)
4.等待状态 —— WAITING(表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定的动作，通知或者中断)
5.超时等待状态 —— TIME_WAITING(该状态不同于 WAITING，它可以在指定的时间自行返回)
6.终止状态 —— TERMINATED(终止状态，表示当前线程已经执行完毕)


转换规则：

       调用 start 方法
1.创建状态 -> 运行状态(就绪)
            获得时间片
2.运行状态(就绪) -> 运行状态(运行中)
   等待进入 sync
3.运行状态 -> 阻塞
    获取到锁
4.阻塞 -> 运行状态
    sleep(100)/Object.wait(100)等
5.运行状态 -> 超时等待状态
       notify/unpark
6.超时等待状态 -> 运行状态
   wait/join/park
7.运行状态 -> 等待状态
     notify/unpark
8.等待状态 -> 运行状态

参考：https://www.zhihu.com/question/56494969




参考：
1.https://www.jianshu.com/p/0adafb219c80