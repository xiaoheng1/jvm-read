计算机是从单核发展到如今的多核. 在这个过程中，必然会尽可能的压榨 CPU 的性能. 所以发展出了多线程技术. 但是多线程技术设计到资源的
竞争，所以我们需要做的事是在保证结果正确的前提下，尽可能快的得到我们想要的结果.

线程安全：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何
其他的协调操作，调用这个对象的行为都可以得到正确的结果，那么这个对象是线程安全的.
上面那段话强调的是对象本身封装了线程同步的逻辑，对外提供接口，供其他线程调用.

Java 中的线程安全等级分类.

1.不可变：不可变的对象一定是线程安全的，例如 String 类. 需要注意的是，final 修饰状态变量时，①不能发生引用逃逸，②对象的方法不能改变
状态值.

2.绝对线程安全：我们先看下 Vector 类，虽然该类的 add()、get() 和 size() 方法都被 synchronized 修饰了，但是该类还不是一个绝对线程
安全的类，例如：
Thread removeThread = new Thread(new Runnable(){
    public void run(){
        for(int i=0; i<vector.size(); i++){
            vector.remove(i);
        }
    }
});

Thread printThread = new Thread(new Runnable(){
    public void run(){
        for(int i=0; i<vector.size(); i++){
            System.out.println(vector.get(i);
        }
    };
});

当 removeThread 线程在错误的时间点删除了某个元素，然后 printThread 在访问的时候可能报错.

3.相对线程安全：相对线程安全就是我们通常意义上说的线程安全, 它需要保证对这个对象的单独操作是线程安全的.

4.线程兼容：线程兼容指的是对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用.

5.线程对立：指的是无论调用端是否采用了同步措施，都无法在多线程环境中并发使用的代码. 例如 Thread 类的 suspend 和 resume 方法，存在
死锁风险.

实现线程安全的办法：

1.互斥同步(synchronized、lock)
synchronized 在实现的时候，是通过在同步代码前后插入 monitorenter 和 monitorexit 两个指令实现的. 同时 synchronized 是可重入锁，
不会把自己锁在外面，当一个线程准备进入同步区时，首先看能否获取到监控对象的锁，如果不能获取，可能先自旋一会，然后自我阻塞. 如果可以获取
到锁，则执行同步代码部分. 上述是同步代码块. 同步方法则是通过一个标志位来实现的.

关于 lock 则是 API 层面的东西，它提供了更多更高级的用法，例如尝试获取锁，中断获取锁，超时获取锁等，实现原理是 volatile + cas.

在 jdk1.6 之前，synchronized 有一个名称叫做重级锁. 因为 Java 中的线程最终会映射到操作系统层面的线程，会涉及到由用户态转变为内核态等.
那时候 synchronized 的性能比 lock 差太大，但是随着后续版本的优化，目前 synchronized 的性能和 lock 差不多了.

2.非阻塞同步(CAS)

CAS 解决了互斥同步中的线程转换所带来的性能消耗，但是其语义上有缺陷，不能识别 ABA 问题. J.U.C 包为了解决这个问题，引入了一个类
AtomicStampedReference，它通过控制变量值的版本来保证 CAS 的正确性(目前大部分 ABA 问题并不影响正确的正确性).

3.无同步方案

如果一个方法本来就不涉及共享数据，那么它自然就无须任何同步措施去保证正确性.
(1)可重入代码(Reentrant Code): 这种代码，可以在任何时刻中断它，转而去执行另一段代码(不依赖存储堆上的数据和公用系统资源、用到的状态
都是由参数中传入、不调用非可重入代码)
(2)线程本地存储：如果一段代码中所需要的数据与其他代码共享，那么就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们
就可以把共享数据的可见范围限制在同一个线程之内.

例如：生产者-消费者 模式，Tomcat 处理请求


锁优化

我们知道，线程挂起和线程恢复需要耗费大量的时间，但是如果共享数据的锁定只是持续很短的一段时间，那么我们是不是能让被墙在外部的线程自己
等会，但不放弃处理器的时间(这就是自旋锁).

自适应锁说的是自旋的时间不固定，由前一次在同一个锁上自旋时间及锁的拥有者的状态来决定.

锁消除

锁消除指的是虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检查到不可能存在共享数据竞争的锁进行消除.

锁粗化

原则上，我们应当尽可能的将同步的部分尽可能的小，从而提高整体的并发. 但是如果是一系列的加锁和解锁，那么即使没有线程竞争，频繁地进行互斥
操作也会导致不必要的性能损耗. 所以，如果虚拟机探测到有一些这样零碎的操作都是对同一个对象加锁，将会把锁粗化到整个操作序列的外部.

轻量级锁

轻量级锁是相对使用互斥来实现同步的. 轻量级锁的使用前提是没有多少线程竞争锁. 我们知道，Java 对象分为对象头、实例数据和对齐填充. 在 Java
对象头中，除了存储对象的 hashCode、GC 分代年龄等，还有 Mark Word.

在代码进入同步代码块时，如果此同步对象没有被锁定(锁标志位为01)，虚拟机首先在当前线程的栈帧中建立一个名为锁记录的空间，用于存储对象目前
的 Mark Word(Displaced Mark Word). 然后虚拟机使用 CAS 尝试将对象的 Mark Word 更新为指向 Lock Recode 的指针. 如果操作成功，
那么这个线程就拥有了锁，并且此对象的锁标志位变为 00.

如果操作失败，则首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那么就可以直接进入同步块
执行，否则说明有两个以上的线程竞争锁，那么此时要膨胀为重级锁，锁标志位变为 10，Mark Word 存储的是重级锁的指针.

偏向锁

引入偏向锁的目的是消除数据在无锁竞争情况下的同步. 偏向锁会偏向第一个获取锁的线程. 当锁对象第一次被线程获取时，虚拟机会将对象头中的标志
位设置为 01，同时使用 CAS 把获得这个锁的线程的 ID 记录到 Mark Word 中，如果设置成功，以后该线程进入这个锁的同步时，虚拟机将不再
进行任何同步操作.

当另一个线程尝试去获取锁，偏向模式宣告结束. 根据对象目前是否处于被锁定的状态，撤销偏向锁后恢复到未锁定的状态或者轻量级锁.

锁升级过程：

(1)一个对象A刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，
所以当第一个线程T1来访问它的时候，它会偏向T1，此时，对象A持有偏向锁.

(2)此时A是偏向第一个线程T1，T1在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，
之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。

(3)一旦有第二个线程T2访问这个对象，因为偏向锁不会主动释放，所以T2可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了。
检查原来持有该对象锁的线程T1是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，
如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，
（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。

 轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下，
即自旋（具体看文末：三、自旋锁），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，
一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转
